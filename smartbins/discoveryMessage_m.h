//
// Generated file, do not edit! Created by opp_msgtool 6.0 from discoveryMessage.msg.
//

#ifndef __DISCOVERYMESSAGE_M_H
#define __DISCOVERYMESSAGE_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// opp_msgtool version check
#define MSGC_VERSION 0x0600
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgtool: 'make clean' should help.
#endif

class discoveryMessage;
// cplusplus {{
    #include <map>
    #include <vector>
    //using namespace omnetpp;
    typedef std::map<int,int> DBresult;
    // this has a problem
    typedef std::vector<omnetpp::cGate *> GateVector;
// }}

/**
 * Class generated from <tt>discoveryMessage.msg:14</tt> by opp_msgtool.
 * <pre>
 * message discoveryMessage
 * {
 *     // ID assigned to QUERY
 *     int queryID;
 *     // this is the identifer of the very first AE generating Discovery QUERY
 *     int URI_init;
 *     // this is identifer of in route CSE, sending the message to another CSE
 *     int URI_route;
 *     // this is type of Resource CSE is looking for. Values can be "waterValve","thermometer","airStation","ATM","smartLock"
 *     string feature_type;
 * 	//this can be Registration, update, cancellation, Query, Response, Notify      
 *     int op_code;
 *     // Indicates result of query
 *     int returnCode;
 *     // It can be set to +1 or -1 respectively to add or remove the AEs from routing table. 
 *     int delta;
 *   	// It is used for notification for measuring the depth of notification 
 *     int hopCount;
 *     // this will be UP (customer to provider) or DOWN (Provider to Customer)
 *     // or SIDE (Sibling to Sibling and Peer to Peer). direction where the message has been sent
 *     int direction;
 *     // this is the index of the gate from which the request has been sent originator gate.
 *     int initialGateIndex;
 *     //This is the result obtained when looking in the local database
 *     DBresult dbResult;
 *     // this is the list that contains the discovery path (list of CSE which forward the query) 
 *     GateVector gateVector;
 * }
 * </pre>
 */
class discoveryMessage : public ::omnetpp::cMessage
{
  protected:
    int queryID = 0;
    int URI_init = 0;
    int URI_route = 0;
    omnetpp::opp_string feature_type;
    int op_code = 0;
    int returnCode = 0;
    int delta = 0;
    int hopCount = 0;
    int direction = 0;
    int initialGateIndex = 0;
    DBresult dbResult;
    GateVector gateVector;

  private:
    void copy(const discoveryMessage& other);

  protected:
    bool operator==(const discoveryMessage&) = delete;

  public:
    discoveryMessage(const char *name=nullptr, short kind=0);
    discoveryMessage(const discoveryMessage& other);
    virtual ~discoveryMessage();
    discoveryMessage& operator=(const discoveryMessage& other);
    virtual discoveryMessage *dup() const override {return new discoveryMessage(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual int getQueryID() const;
    virtual void setQueryID(int queryID);

    virtual int getURI_init() const;
    virtual void setURI_init(int URI_init);

    virtual int getURI_route() const;
    virtual void setURI_route(int URI_route);

    virtual const char * getFeature_type() const;
    virtual void setFeature_type(const char * feature_type);

    virtual int getOp_code() const;
    virtual void setOp_code(int op_code);

    virtual int getReturnCode() const;
    virtual void setReturnCode(int returnCode);

    virtual int getDelta() const;
    virtual void setDelta(int delta);

    virtual int getHopCount() const;
    virtual void setHopCount(int hopCount);

    virtual int getDirection() const;
    virtual void setDirection(int direction);

    virtual int getInitialGateIndex() const;
    virtual void setInitialGateIndex(int initialGateIndex);

    virtual const DBresult& getDbResult() const;
    virtual DBresult& getDbResultForUpdate() { return const_cast<DBresult&>(const_cast<discoveryMessage*>(this)->getDbResult());}
    virtual void setDbResult(const DBresult& dbResult);

    virtual const GateVector& getGateVector() const;
    virtual GateVector& getGateVectorForUpdate() { return const_cast<GateVector&>(const_cast<discoveryMessage*>(this)->getGateVector());}
    virtual void setGateVector(const GateVector& gateVector);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const discoveryMessage& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, discoveryMessage& obj) {obj.parsimUnpack(b);}


namespace omnetpp {

inline any_ptr toAnyPtr(const DBresult *p) {if (auto obj = as_cObject(p)) return any_ptr(obj); else return any_ptr(p);}
template<> inline DBresult *fromAnyPtr(any_ptr ptr) { return ptr.get<DBresult>(); }
inline any_ptr toAnyPtr(const GateVector *p) {if (auto obj = as_cObject(p)) return any_ptr(obj); else return any_ptr(p);}
template<> inline GateVector *fromAnyPtr(any_ptr ptr) { return ptr.get<GateVector>(); }
template<> inline discoveryMessage *fromAnyPtr(any_ptr ptr) { return check_and_cast<discoveryMessage*>(ptr.get<cObject>()); }

}  // namespace omnetpp

#endif // ifndef __DISCOVERYMESSAGE_M_H

