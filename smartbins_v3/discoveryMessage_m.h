//
// Generated file, do not edit! Created by opp_msgtool 6.0 from discoveryMessage.msg.
//

#ifndef __DISCOVERYMESSAGE_M_H
#define __DISCOVERYMESSAGE_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// opp_msgtool version check
#define MSGC_VERSION 0x0600
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgtool: 'make clean' should help.
#endif

class discoveryMessage;
// cplusplus {{
  #include <map>
  #include <vector>
  typedef std::map<int,int> DBresult;
  typedef std::vector<omnetpp::cGate *> GateVector;
// }}

/**
 * Class generated from <tt>discoveryMessage.msg:11</tt> by opp_msgtool.
 * <pre>
 * message discoveryMessage
 * {
 *     int queryID;  // ID assigned to QUERY
 * 
 *     int URI_init; // this is identifier of the very first AE generating Discovery QUERY
 * 
 *     int URI_route;  // this is identifier of in route CSE, sending the message to another CSE
 * 
 *     string feature_type;  // this is type of Resource CSE is looking for.
 * 
 *     int op_code;  // this can be
 *                 // REGISTRATION (value = 0)
 *                 // UPDATE (value = 1)
 *                 // CANCELLATION (value = 2)
 *                 // QUERY (value = 3)
 *                 // RESPONSE (value = 4)
 *                 // NOTIFY (value = 5)
 * 
 *     int returnCode; // It can be set to +1 or -1 respectively to add or remove the AEs from routing table.
 * 
 *     int delta; // It is used for notification for measuring depth of notification
 * 
 *     int hopCount; // It is used for notification for measuring the depth of notificaiton
 * 
 *     int direction;  // this will be direction where the message has been sent
 *                   // UP (customer to provider)
 *                   // DOWN (provider to customer)
 *                   // SIDE (sibling to sling or peer to peer)
 * 
 *     int initialGateIndex; // this is the index of the gate from which the request has been sent, originator gate.
 * 
 *     DBresult dbResult;  // this is the result obtained when looking in the local database
 * 
 *     GateVector gateVector;
 * }
 * </pre>
 */
class discoveryMessage : public ::omnetpp::cMessage
{
  protected:
    int queryID = 0;
    int URI_init = 0;
    int URI_route = 0;
    omnetpp::opp_string feature_type;
    int op_code = 0;
    int returnCode = 0;
    int delta = 0;
    int hopCount = 0;
    int direction = 0;
    int initialGateIndex = 0;
    DBresult dbResult;
    GateVector gateVector;

  private:
    void copy(const discoveryMessage& other);

  protected:
    bool operator==(const discoveryMessage&) = delete;

  public:
    discoveryMessage(const char *name=nullptr, short kind=0);
    discoveryMessage(const discoveryMessage& other);
    virtual ~discoveryMessage();
    discoveryMessage& operator=(const discoveryMessage& other);
    virtual discoveryMessage *dup() const override {return new discoveryMessage(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual int getQueryID() const;
    virtual void setQueryID(int queryID);

    virtual int getURI_init() const;
    virtual void setURI_init(int URI_init);

    virtual int getURI_route() const;
    virtual void setURI_route(int URI_route);

    virtual const char * getFeature_type() const;
    virtual void setFeature_type(const char * feature_type);

    virtual int getOp_code() const;
    virtual void setOp_code(int op_code);

    virtual int getReturnCode() const;
    virtual void setReturnCode(int returnCode);

    virtual int getDelta() const;
    virtual void setDelta(int delta);

    virtual int getHopCount() const;
    virtual void setHopCount(int hopCount);

    virtual int getDirection() const;
    virtual void setDirection(int direction);

    virtual int getInitialGateIndex() const;
    virtual void setInitialGateIndex(int initialGateIndex);

    virtual const DBresult& getDbResult() const;
    virtual DBresult& getDbResultForUpdate() { return const_cast<DBresult&>(const_cast<discoveryMessage*>(this)->getDbResult());}
    virtual void setDbResult(const DBresult& dbResult);

    virtual const GateVector& getGateVector() const;
    virtual GateVector& getGateVectorForUpdate() { return const_cast<GateVector&>(const_cast<discoveryMessage*>(this)->getGateVector());}
    virtual void setGateVector(const GateVector& gateVector);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const discoveryMessage& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, discoveryMessage& obj) {obj.parsimUnpack(b);}


namespace omnetpp {

inline any_ptr toAnyPtr(const DBresult *p) {if (auto obj = as_cObject(p)) return any_ptr(obj); else return any_ptr(p);}
template<> inline DBresult *fromAnyPtr(any_ptr ptr) { return ptr.get<DBresult>(); }
inline any_ptr toAnyPtr(const GateVector *p) {if (auto obj = as_cObject(p)) return any_ptr(obj); else return any_ptr(p);}
template<> inline GateVector *fromAnyPtr(any_ptr ptr) { return ptr.get<GateVector>(); }
template<> inline discoveryMessage *fromAnyPtr(any_ptr ptr) { return check_and_cast<discoveryMessage*>(ptr.get<cObject>()); }

}  // namespace omnetpp

#endif // ifndef __DISCOVERYMESSAGE_M_H

